#!/usr/bin/env python3

import argparse
import os
import sys
import textwrap

from nltk.corpus import wordnet as wn

sys.path.insert(1, os.path.join(sys.path[0], ('..')))

from colorization.util.resources import get_resource_path


KAGGLE_IMAGENET_LABELS = 'LOC_synset_mapping.txt'

USAGE = """\
imagenet_neighbours [-h|--help]
                           [--list-synsets]
                           [--plaintext-only]
                           [--synset-only]
                           [--sort {similarity,synset,plaintext}]
                           SYNSET N
"""


synset_ids = {}

with open(get_resource_path(KAGGLE_IMAGENET_LABELS), 'r') as f:
    for line in f:
        line = line.rstrip()

        synset_id, nouns = line.split(maxsplit=1)
        main_noun = nouns.split(', ', 1)[0].lower()

        synset_ids[main_noun] = synset_id


class ListSynsets(argparse.Action):
    def __call__(self, parser, args, values, option_string=None):
        print('\n'.join(sorted(synset_ids.keys())))
        parser.exit()


if __name__ == '__main__':
    # parse command line arguments
    parser = argparse.ArgumentParser(
        usage=USAGE,
        description=str("Find semantically close ImageNet synsets from their "
                        "WordNet path similarities."))

    parser.add_argument('synset',
                        metavar='SYNSET',
                        help=str("plaintext shorthand for synset for which to "
                                 "determine neighbours"))

    parser.add_argument('n',
                        metavar='N',
                        type=int,
                        help="number of neighbours to list")

    parser.add_argument('--list-synsets',
                        action=ListSynsets,
                        nargs=0,
                        help=str("ignore other options and display plaintext "
                                 "shorthands of all available synsets"))

    parser.add_argument('--plaintext-only',
                        action='store_true',
                        help="only display plaintext shorthands")

    parser.add_argument('--synset-only',
                        action='store_true',
                        help="only display synset ids")

    parser.add_argument('--sort',
                        choices=['similarity', 'synset', 'plaintext'],
                        default='similarity')

    args = parser.parse_args()

    if args.plaintext_only and args.synset_only:
        err = "--plaintext-only and --synset-only may not be specified together"
        print(err, file=sys.stderr)
        sys.exit(1)

    # parse imagenet labels
    noun = args.synset

    if noun not in synset_ids:
        fmt = "'{}' is not a valid synset plaintext shorthand"
        print(fmt.format(noun, file=sys.stderr))
        sys.exit(1)

    noun_id = synset_ids[noun]

    similarities = []

    for other, other_id in synset_ids.items():
        s_noun = wn.synset_from_pos_and_offset('n', int(noun_id[1:]))
        s_other = wn.synset_from_pos_and_offset('n', int(other_id[1:]))

        sim = wn.path_similarity(s_noun, s_other)
        similarities.append((synset_ids[other], other, sim))

    similarities.sort(key=lambda sim: -sim[2])
    similarities = similarities[:args.n]

    if args.sort == 'synset':
        similarities.sort(key=lambda sim: sim[0])
    elif args.sort == 'plaintext':
        similarities.sort(key=lambda sim: sim[1])

    for synset, plaintext, _ in similarities:
        if args.plaintext_only:
            print(plaintext)
        elif args.synset_only:
            print(synset)
        else:
            print(synset, plaintext)
